# 테스트 설계 명세서: 반복 일정 기능

## 기본 정보

- **Task ID**: task-20251031-000000
- **작성일**: 2025-10-31
- **작성자**: Test Designer Agent
- **기능 명세서**: `bmad-tdd/tdd/artifacts/features/task-20251031-000000.md`

---

## 테스트 전략

### 테스트 범위

- **단위 테스트**: 반복 일정 생성 유틸 함수
  - `src/utils/repeatEventUtils.ts` - generateRepeatEvents, getNextOccurrenceDate, isValidRepeatDate
  - 순수 함수로 구현되어 독립적인 테스트 가능
- **훅 테스트**: 반복 일정 저장 로직
  - `src/hooks/useEventOperations.ts` - saveEvent 함수의 반복 일정 처리
  - MSW를 사용한 API 호출 검증
- **통합 테스트**: UI + 반복 일정 생성 플로우 (선택적)
  - 반복 일정 체크박스 ~ 저장까지 전체 흐름
  - 우선순위가 낮으므로 시간이 허용되면 작성

### 테스트 우선순위

1. **Critical (18개)**: 핵심 반복 생성 로직, 특수 케이스 처리, API 호출
2. **Important (8개)**: 엣지 케이스, 에러 처리, 유효성 검증
3. **Nice to have (4개)**: 성능 제한, 추가 엣지 케이스

**총 예상 테스트 케이스**: 30개

---

## 테스트 케이스 상세

### A. 단위 테스트 - generateRepeatEvents

#### TC-A1: 매일 반복 - 기본 동작

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-01, 매일 반복, 간격 1, 종료일 2025-01-05
- 최대 생성 개수: 100 (기본값)

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-01-01, 01-02, 01-03, 01-04, 01-05
- 모든 이벤트가 동일한 title, startTime, endTime을 가진다
- repeat 정보가 모든 이벤트에 포함된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A2: 매일 반복 - 간격 2일

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-01, 매일 반복, 간격 2, 종료일 2025-01-10

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-01-01, 01-03, 01-05, 01-07, 01-09
- 2일 간격으로 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A3: 매주 반복 - 기본 동작

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-06 (월요일), 매주 반복, 간격 1, 종료일 2025-02-03

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-01-06, 01-13, 01-20, 01-27, 02-03 (모두 월요일)
- 요일이 동일하다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A4: 매주 반복 - 간격 2주

**우선순위**: Important

**Arrange**

- 기준 이벤트: 2025-01-06 (월요일), 매주 반복, 간격 2, 종료일 2025-02-17

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 3개의 이벤트가 생성된다
- 날짜: 2025-01-06, 01-20, 02-03
- 2주 간격으로 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A5: 매월 반복 - 기본 동작 (일반 날짜)

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-15, 매월 반복, 간격 1, 종료일 2025-05-15

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-01-15, 02-15, 03-15, 04-15, 05-15
- 모든 달에서 15일에 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A6: 매월 반복 - 31일 특수 케이스

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-31, 매월 반복, 간격 1, 종료일 2025-12-31

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 7개의 이벤트가 생성된다
- 날짜: 2025-01-31, 03-31, 05-31, 07-31, 08-31, 10-31, 12-31
- 31일이 없는 달(2, 4, 6, 9, 11월)은 건너뛴다
- 2월 28일이나 30일로 생성되지 않는다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A7: 매월 반복 - 30일 날짜

**우선순위**: Important

**Arrange**

- 기준 이벤트: 2025-01-30, 매월 반복, 간격 1, 종료일 2025-12-30

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 11개의 이벤트가 생성된다 (2월만 제외)
- 날짜: 1/30, 3/30, 4/30, 5/30, 6/30, 7/30, 8/30, 9/30, 10/30, 11/30, 12/30
- 2월은 건너뛴다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A8: 매월 반복 - 간격 2개월

**우선순위**: Important

**Arrange**

- 기준 이벤트: 2025-01-15, 매월 반복, 간격 2, 종료일 2025-09-15

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-01-15, 03-15, 05-15, 07-15, 09-15
- 2개월 간격으로 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A9: 매년 반복 - 기본 동작

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-03-15, 매년 반복, 간격 1, 종료일 2029-03-15

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-03-15, 2026-03-15, 2027-03-15, 2028-03-15, 2029-03-15
- 매년 같은 날짜에 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A10: 매년 반복 - 2월 29일 윤년 케이스

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2024-02-29 (윤년), 매년 반복, 간격 1, 종료일 2032-02-29

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 3개의 이벤트가 생성된다
- 날짜: 2024-02-29, 2028-02-29, 2032-02-29 (모두 윤년)
- 평년(2025, 2026, 2027, 2029, 2030, 2031)은 건너뛴다
- 2월 28일이나 3월 1일로 생성되지 않는다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A11: 매년 반복 - 간격 2년

**우선순위**: Important

**Arrange**

- 기준 이벤트: 2025-06-15, 매년 반복, 간격 2, 종료일 2033-06-15

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 5개의 이벤트가 생성된다
- 날짜: 2025-06-15, 2027-06-15, 2029-06-15, 2031-06-15, 2033-06-15
- 2년 간격으로 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A12: 종료일이 없는 경우 - 2년 제한

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-01, 매일 반복, 간격 1, 종료일 없음
- 최대 생성 개수: 100

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 100개의 이벤트가 생성된다 (최대 제한)
- 또는 2년치 이벤트가 생성된다 (365 \* 2 = 730개 중 100개만)
- 더 이상 생성되지 않는다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A13: 최대 이벤트 개수 제한 (100개)

**우선순위**: Critical

**Arrange**

- 기준 이벤트: 2025-01-01, 매일 반복, 간격 1, 종료일 2026-01-01 (365일)
- 최대 생성 개수: 100

**Act**

- `generateRepeatEvents(baseEvent, 100)` 호출

**Assert**

- 정확히 100개의 이벤트만 생성된다
- 365개가 아닌 100개로 제한된다
- 2025-01-01부터 2025-04-10까지 생성된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A14: 종료일이 기준일과 동일한 경우

**우선순위**: Important

**Arrange**

- 기준 이벤트: 2025-01-01, 매일 반복, 간격 1, 종료일 2025-01-01

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 1개의 이벤트만 생성된다 (기준일)
- 날짜: 2025-01-01

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-A15: 종료일이 기준일보다 이전인 경우

**우선순위**: Important

**Arrange**

- 기준 이벤트: 2025-01-10, 매일 반복, 간격 1, 종료일 2025-01-05

**Act**

- `generateRepeatEvents(baseEvent)` 호출

**Assert**

- 1개의 이벤트만 생성된다 (기준일만)
- 또는 빈 배열이 반환된다 (구현 방식에 따라)

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

### B. 단위 테스트 - getNextOccurrenceDate

#### TC-B1: 매일 반복 - 다음 날짜 계산

**우선순위**: Critical

**Arrange**

- 현재 날짜: 2025-01-01
- 기준 날짜: 2025-01-01
- 반복 유형: daily, 간격: 1

**Act**

- `getNextOccurrenceDate(currentDate, baseDate, 'daily', 1)` 호출

**Assert**

- 반환값: 2025-01-02
- 1일 후의 날짜가 반환된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-B2: 매주 반복 - 다음 같은 요일 계산

**우선순위**: Critical

**Arrange**

- 현재 날짜: 2025-01-06 (월요일)
- 기준 날짜: 2025-01-06
- 반복 유형: weekly, 간격: 1

**Act**

- `getNextOccurrenceDate(currentDate, baseDate, 'weekly', 1)` 호출

**Assert**

- 반환값: 2025-01-13 (다음 월요일)
- 7일 후의 날짜가 반환된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-B3: 매월 반복 - 다음 같은 날짜 계산 (일반)

**우선순위**: Critical

**Arrange**

- 현재 날짜: 2025-01-15
- 기준 날짜: 2025-01-15
- 반복 유형: monthly, 간격: 1

**Act**

- `getNextOccurrenceDate(currentDate, baseDate, 'monthly', 1)` 호출

**Assert**

- 반환값: 2025-02-15
- 다음 달 같은 날짜가 반환된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-B4: 매월 반복 - 31일 다음 발생 계산 (건너뛰기)

**우선순위**: Critical

**Arrange**

- 현재 날짜: 2025-01-31
- 기준 날짜: 2025-01-31
- 반복 유형: monthly, 간격: 1

**Act**

- `getNextOccurrenceDate(currentDate, baseDate, 'monthly', 1)` 호출

**Assert**

- 반환값: 2025-03-31 (2월은 건너뜀)
- 2025-02-28이나 2025-02-31이 아니다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-B5: 매년 반복 - 다음 같은 날짜 계산

**우선순위**: Critical

**Arrange**

- 현재 날짜: 2025-03-15
- 기준 날짜: 2025-03-15
- 반복 유형: yearly, 간격: 1

**Act**

- `getNextOccurrenceDate(currentDate, baseDate, 'yearly', 1)` 호출

**Assert**

- 반환값: 2026-03-15
- 1년 후 같은 날짜가 반환된다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-B6: 매년 반복 - 2월 29일 다음 발생 (윤년 건너뛰기)

**우선순위**: Critical

**Arrange**

- 현재 날짜: 2024-02-29 (윤년)
- 기준 날짜: 2024-02-29
- 반복 유형: yearly, 간격: 1

**Act**

- `getNextOccurrenceDate(currentDate, baseDate, 'yearly', 1)` 호출

**Assert**

- 반환값: 2028-02-29 (다음 윤년)
- 2025, 2026, 2027년은 건너뛴다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

### C. 단위 테스트 - isValidRepeatDate

#### TC-C1: 매월 반복 - 31일이 유효한 달

**우선순위**: Critical

**Arrange**

- 검증 날짜: 2025-01-31
- 기준 날짜: 2025-01-31
- 반복 유형: monthly

**Act**

- `isValidRepeatDate(date, baseDate, 'monthly')` 호출

**Assert**

- 반환값: true
- 1월은 31일이 존재한다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-C2: 매월 반복 - 31일이 유효하지 않은 달

**우선순위**: Critical

**Arrange**

- 검증 날짜: 2025-02-31 (존재하지 않음)
- 기준 날짜: 2025-01-31
- 반복 유형: monthly

**Act**

- `isValidRepeatDate(new Date(2025, 1, 31), baseDate, 'monthly')` 호출

**Assert**

- 반환값: false
- 2월은 31일이 없다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-C3: 매년 반복 - 윤년 2월 29일 유효

**우선순위**: Critical

**Arrange**

- 검증 날짜: 2024-02-29 (윤년)
- 기준 날짜: 2024-02-29
- 반복 유형: yearly

**Act**

- `isValidRepeatDate(date, baseDate, 'yearly')` 호출

**Assert**

- 반환값: true
- 2024년은 윤년이므로 2월 29일이 유효하다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-C4: 매년 반복 - 평년 2월 29일 무효

**우선순위**: Critical

**Arrange**

- 검증 날짜: 2025-02-29 (평년)
- 기준 날짜: 2024-02-29
- 반복 유형: yearly

**Act**

- `isValidRepeatDate(new Date(2025, 1, 29), baseDate, 'yearly')` 호출

**Assert**

- 반환값: false
- 2025년은 평년이므로 2월 29일이 무효하다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

#### TC-C5: 매일/매주 반복 - 항상 유효

**우선순위**: Important

**Arrange**

- 검증 날짜: 2025-02-28
- 기준 날짜: 2025-01-01
- 반복 유형: daily 또는 weekly

**Act**

- `isValidRepeatDate(date, baseDate, 'daily')` 호출
- `isValidRepeatDate(date, baseDate, 'weekly')` 호출

**Assert**

- 반환값: 모두 true
- 매일/매주 반복은 날짜 검증이 필요 없다

**테스트 파일**: `src/__tests__/unit/easy.repeatEventUtils.spec.ts`

---

### D. 훅 테스트 - useEventOperations (반복 일정 저장)

#### TC-D1: 반복 일정 저장 시 /api/events-list 호출

**우선순위**: Critical

**Arrange**

- MSW 핸들러: POST /api/events-list 모킹 (성공 응답)
- 반복 이벤트: 2025-01-01, 매일 반복, 간격 1, 종료일 2025-01-03

**Act**

- `saveEvent(repeatEvent)` 호출

**Assert**

- POST /api/events-list가 호출된다 (POST /api/events가 아님)
- 요청 body: `{ events: [event1, event2, event3] }` (3개 이벤트 배열)
- 성공 메시지: "3개의 반복 일정이 생성되었습니다" 표시

**테스트 파일**: `src/__tests__/hooks/medium.useEventOperations.spec.ts`

---

#### TC-D2: 일반 일정 저장 시 기존 /api/events 호출 유지

**우선순위**: Critical

**Arrange**

- MSW 핸들러: POST /api/events 모킹 (성공 응답)
- 일반 이벤트: repeat.type = 'none'

**Act**

- `saveEvent(normalEvent)` 호출

**Assert**

- POST /api/events가 호출된다 (기존 동작 유지)
- POST /api/events-list가 호출되지 않는다
- 성공 메시지: "일정이 추가되었습니다" 표시

**테스트 파일**: `src/__tests__/hooks/medium.useEventOperations.spec.ts`

---

#### TC-D3: 반복 일정 수정 시 개별 이벤트만 수정

**우선순위**: Important

**Arrange**

- 기존 반복 일정 3개 존재
- editing = true
- 수정할 이벤트: 반복 일정 중 하나

**Act**

- `saveEvent(updatedEvent)` 호출

**Assert**

- PUT /api/events/:id가 호출된다 (단일 이벤트만 수정)
- 다른 반복 일정은 영향받지 않는다

**테스트 파일**: `src/__tests__/hooks/medium.useEventOperations.spec.ts`

---

#### TC-D4: 반복 일정 생성 실패 시 에러 처리

**우선순위**: Important

**Arrange**

- MSW 핸들러: POST /api/events-list 모킹 (500 에러)
- 반복 이벤트

**Act**

- `saveEvent(repeatEvent)` 호출

**Assert**

- 에러 메시지: "반복 일정 생성에 실패했습니다. 다시 시도해주세요." 표시
- events 상태가 변경되지 않는다 (롤백)

**테스트 파일**: `src/__tests__/hooks/medium.useEventOperations.spec.ts`

---

#### TC-D5: 반복 일정이 100개 초과 시 경고

**우선순위**: Nice to have

**Arrange**

- 반복 이벤트: 365일 매일 반복 (100개 초과)

**Act**

- `saveEvent(repeatEvent)` 호출

**Assert**

- 100개 이벤트만 생성된다
- 경고 메시지: "반복 일정이 너무 많아 100개까지만 생성되었습니다" 표시

**테스트 파일**: `src/__tests__/hooks/medium.useEventOperations.spec.ts`

---

### E. 통합 테스트 - UI (선택적)

#### TC-E1: 반복 일정 체크박스 토글

**우선순위**: Nice to have

**Arrange**

- 일정 추가 폼이 렌더링됨

**Act**

- "반복 일정" 체크박스 클릭

**Assert**

- 반복 설정 UI가 표시된다
- 반복 유형 드롭다운, 반복 간격 입력, 종료일 입력이 보인다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/i });
```

---

#### TC-E2: 반복 유형 선택 및 일정 생성

**우선순위**: Nice to have

**Arrange**

- 일정 추가 폼에 기본 정보 입력
- 반복 일정 체크박스 선택

**Act**

- 반복 유형: "매주" 선택
- 반복 간격: 1 입력
- 종료일: 3주 후 선택
- "일정 추가" 버튼 클릭

**Assert**

- 로딩 인디케이터 표시: "반복 일정 생성 중..."
- POST /api/events-list 호출 확인
- 성공 메시지: "4개의 반복 일정이 생성되었습니다"
- 캘린더에 4개 일정이 표시됨

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

#### TC-E3: 반복 일정 생성 시 겹침 체크 제외

**우선순위**: Critical

**Arrange**

- 기존 일정: 2025-01-01 10:00-11:00
- 새 반복 일정: 2025-01-01 시작, 매일 반복, 10:00-11:00 (겹침)

**Act**

- 반복 일정 생성

**Assert**

- 겹침 경고 다이얼로그가 표시되지 않는다
- 일정이 바로 생성된다
- 두 일정이 모두 캘린더에 표시된다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

## 테스트 데이터 정의

### Mock 데이터

```typescript
// 기본 반복 이벤트 데이터
const mockRepeatEventDaily: EventForm = {
  title: '매일 회의',
  date: '2025-01-01',
  startTime: '10:00',
  endTime: '11:00',
  description: '일일 스탠드업',
  location: '회의실 A',
  category: '업무',
  repeat: {
    type: 'daily',
    interval: 1,
    endDate: '2025-01-05',
  },
  notificationTime: 10,
};

const mockRepeatEventWeekly: EventForm = {
  ...mockRepeatEventDaily,
  title: '주간 회의',
  date: '2025-01-06', // 월요일
  repeat: {
    type: 'weekly',
    interval: 1,
    endDate: '2025-02-03',
  },
};

const mockRepeatEventMonthly31st: EventForm = {
  ...mockRepeatEventDaily,
  title: '월말 정산',
  date: '2025-01-31',
  repeat: {
    type: 'monthly',
    interval: 1,
    endDate: '2025-12-31',
  },
};

const mockRepeatEventYearlyLeap: EventForm = {
  ...mockRepeatEventDaily,
  title: '윤년 기념일',
  date: '2024-02-29',
  repeat: {
    type: 'yearly',
    interval: 1,
    endDate: '2032-02-29',
  },
};

// API 응답 데이터
const mockEventsListResponse = {
  events: [
    { id: '1', ...mockRepeatEventDaily, date: '2025-01-01' },
    { id: '2', ...mockRepeatEventDaily, date: '2025-01-02' },
    { id: '3', ...mockRepeatEventDaily, date: '2025-01-03' },
  ],
};
```

### Fixture 데이터

```typescript
// 윤년 판정 테스트용
const leapYears = [2024, 2028, 2032, 2000, 2400];
const nonLeapYears = [2023, 2025, 2026, 2027, 1900, 2100];

// 31일이 있는/없는 달
const monthsWith31Days = [1, 3, 5, 7, 8, 10, 12];
const monthsWith30Days = [4, 6, 9, 11];
const february = 2;
```

---

## Mock/Stub 전략

### API Mocking (MSW)

```typescript
import { http, HttpResponse } from 'msw';

// 반복 일정 생성 성공
const repeatEventsCreationHandler = http.post('/api/events-list', async ({ request }) => {
  const body = await request.json();
  const { events } = body;

  // repeatId 추가하여 반환
  const eventsWithIds = events.map((event, index) => ({
    ...event,
    id: `repeat-${Date.now()}-${index}`,
    repeat: {
      ...event.repeat,
      id: 'repeat-group-123',
    },
  }));

  return HttpResponse.json(eventsWithIds, { status: 201 });
});

// 반복 일정 생성 실패
const repeatEventsCreationErrorHandler = http.post('/api/events-list', () => {
  return new HttpResponse(null, { status: 500 });
});
```

### 시간 Mocking

```typescript
import { beforeEach, afterEach } from 'vitest';

describe('repeatEventUtils - 날짜 계산', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2025-01-01T00:00:00Z'));
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  // 테스트 케이스들...
});
```

---

## 테스트 파일 구조

```
src/__tests__/
  └── unit/
      └── easy.repeatEventUtils.spec.ts     # 반복 일정 유틸 단위 테스트
  └── hooks/
      └── medium.useEventOperations.spec.ts # 기존 파일에 반복 일정 테스트 추가
  └── medium.integration.spec.tsx            # 통합 테스트 (선택적)
```

### 예상 테스트 파일 목록

1. `src/__tests__/unit/easy.repeatEventUtils.spec.ts` - 반복 일정 생성 로직 단위 테스트 (22개 테스트)
2. `src/__tests__/hooks/medium.useEventOperations.spec.ts` - 기존 파일에 5개 테스트 추가
3. `src/__tests__/medium.integration.spec.tsx` - 통합 테스트 3개 추가 (선택적)

---

## React Testing Library 쿼리 전략

### 사용할 쿼리 (우선순위 순)

1. **getByRole**: 폼 요소, 버튼

```typescript
screen.getByRole('checkbox', { name: /반복 일정/i });
screen.getByRole('combobox', { name: /반복 유형/i });
screen.getByRole('spinbutton', { name: /반복 간격/i });
screen.getByRole('button', { name: /일정 추가/i });
```

2. **getByLabelText**: 레이블이 있는 입력 필드

```typescript
screen.getByLabelText(/반복 종료일/i);
```

3. **getByText**: 텍스트 콘텐츠

```typescript
screen.getByText(/반복 일정 생성 중/i);
await screen.findByText(/3개의 반복 일정이 생성되었습니다/i);
```

4. **getByTestId**: 최후의 수단 (사용 지양)

### 비동기 처리

```typescript
// API 호출 후 메시지 표시 대기
const successMessage = await screen.findByText(/3개의 반복 일정이 생성되었습니다/i);

// API 호출 검증
await waitFor(() => {
  expect(mockPostEventsListApi).toHaveBeenCalledWith({
    events: expect.arrayContaining([
      expect.objectContaining({ date: '2025-01-01' }),
      expect.objectContaining({ date: '2025-01-02' }),
      expect.objectContaining({ date: '2025-01-03' }),
    ]),
  });
});

// 로딩 상태 사라짐 대기
await waitForElementToBeRemoved(() => screen.queryByText(/반복 일정 생성 중/i));
```

---

## 엣지 케이스 테스트

### 1. 존재하지 않는 날짜 설정 (JavaScript Date 동작)

- **시나리오**: new Date(2025, 1, 31) 생성 시 JavaScript가 자동으로 3월 3일로 조정
- **검증 항목**:
  - 조정된 날짜가 아닌 원래 의도한 31일만 검증
  - isValidRepeatDate로 유효성 체크
  - 무효한 날짜는 건너뛰기

### 2. 연도 경계 넘기 (12월 → 1월)

- **시나리오**: 2024-12-31 매주 반복 → 2025-01-07
- **검증 항목**:
  - 연도가 정확히 증가하는가
  - 월이 1월로 리셋되는가
  - 날짜 계산이 정확한가

### 3. 윤년 경계 (2월 28일 → 2월 29일 또는 3월 1일)

- **시나리오**: 2024-02-28 매일 반복 → 2024-02-29 (윤년) 또는 2025-02-28 매일 반복 → 2025-03-01 (평년)
- **검증 항목**:
  - 윤년과 평년을 정확히 구분하는가
  - 2월 마지막 날이 올바른가

### 4. 매우 큰 반복 간격

- **시나리오**: 매일 반복, 간격 365일 (사실상 매년)
- **검증 항목**:
  - 계산이 정확한가
  - 성능 문제는 없는가

### 5. 과거 날짜로 반복 일정 생성

- **시나리오**: 2020-01-01부터 매일 반복, 종료일 2020-01-10
- **검증 항목**:
  - 과거 날짜에도 정상 동작하는가
  - 현재 날짜와 무관하게 동작하는가

---

## 에러 처리 테스트

### 1. API 호출 실패 (네트워크 오류)

- **발생 조건**: POST /api/events-list 호출 시 500 에러
- **예상 동작**:
  - 에러 메시지: "반복 일정 생성에 실패했습니다. 다시 시도해주세요."
  - 부분 생성 없음 (all or nothing)
  - events 상태 롤백
- **검증 방법**: MSW 핸들러로 500 에러 모킹, enqueueSnackbar 호출 검증

### 2. 유효하지 않은 반복 간격

- **발생 조건**: 반복 간격이 0 이하
- **예상 동작**:
  - 1개 이벤트만 생성 (기준일)
  - 또는 에러 메시지 표시
- **검증 방법**: interval: 0 또는 -1로 테스트

### 3. 반복 유형이 'none'인데 반복 설정 있음

- **발생 조건**: repeat.type = 'none'이지만 interval, endDate가 설정됨
- **예상 동작**:
  - 단일 일정으로 처리
  - POST /api/events 호출 (반복 아님)
- **검증 방법**: 타입과 실제 값의 불일치 케이스

---

## 테스트 체크리스트

### 테스트 작성 전

- [ ] 기능 명세서 검토 완료
- [ ] 24개 인수 조건을 테스트 케이스로 변환 완료
- [ ] Mock 전략이 명확한가? (MSW 핸들러, Fake Timers)
- [ ] 테스트 데이터가 준비되었는가? (mockRepeatEventDaily 등)

### 테스트 작성 중

- [ ] AAA 패턴을 따르는가? (Arrange-Act-Assert)
- [ ] 접근성 쿼리를 우선 사용하는가? (getByRole > getByLabelText)
- [ ] userEvent를 사용하는가? (통합 테스트)
- [ ] 비동기 처리가 적절한가? (findBy, waitFor)
- [ ] 테스트 이름이 명확한가? ("31일에 매월 반복을 선택한 경우 31일이 존재하는 달에만 일정이 생성된다")

### 테스트 작성 후

- [ ] 모든 테스트가 실패하는가? (RED 단계)
- [ ] 특수 케이스 테스트가 포함되었는가? (31일 매월, 2월 29일 매년)
- [ ] 중복 코드가 없는가? (beforeEach로 공통 설정)
- [ ] 테스트가 독립적으로 실행 가능한가?
- [ ] 성능이 적절한가? (30개 테스트가 5초 이내)

---

## 참고 문서

- TDD 워크플로우 가이드: `docs/tdd-workflow-guide.md`
- 프로젝트 구조: `bmad-tdd/core/index.mdc`
- 기능 명세서: `bmad-tdd/tdd/artifacts/features/task-20251031-000000.md`
- 작업 범위 분석: `bmad-tdd/tdd/artifacts/features/task-20251031-000000-scope-analysis.md`

---

## 테스트 커버리지 목표

| 구분               | 목표         | 비고                      |
| ------------------ | ------------ | ------------------------- |
| 인수 조건 커버율   | 24/24 (100%) | 모든 인수 조건이 테스트됨 |
| 엣지 케이스 커버율 | 8/8 (100%)   | 모든 엣지 케이스 테스트됨 |
| 특수 케이스        | 2/2 (100%)   | 31일 매월, 2월 29일 매년  |
| 라인 커버리지      | 95% 이상     | repeatEventUtils.ts       |
| 브랜치 커버리지    | 90% 이상     | 모든 분기 처리            |

---

## 예상 테스트 실행 시간

- 단위 테스트 (22개): 약 2초
- 훅 테스트 (5개): 약 2초
- 통합 테스트 (3개): 약 3초

**총 예상 시간**: 약 7초

---

**문서 버전**: 1.0  
**최종 업데이트**: 2025-10-31

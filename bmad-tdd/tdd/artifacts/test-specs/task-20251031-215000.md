# 테스트 설계 명세서: 반복 일정 종료 조건 설정

## 📋 기본 정보

- **Task ID**: task-20251031-215000
- **작성일**: 2025-10-31
- **작성자**: Test Designer Agent
- **기능 명세서**: `bmad-tdd/tdd/artifacts/features/task-20251031-215000.md`

---

## 🎯 테스트 전략

### 테스트 범위

- **단위 테스트**: 반복 종료일 검증 함수
  - `src/utils/repeatEndDateValidation.ts` (신규)
  - 입력: 시작일, 종료일, 최대 날짜
  - 출력: 에러 메시지 또는 null
- **통합 테스트**: 반복 일정 생성 및 UI 인터랙션
  - `src/App.tsx` - 반복 설정 UI 활성화
  - 반복 체크박스 → 반복 설정 UI 표시
  - 반복 일정 생성 → 종료일까지만 생성
- **E2E 테스트**: 필요 없음 (통합 테스트로 충분)

### 테스트 우선순위

1. 🔴 **Critical** (5개)

   - 반복 설정 UI 렌더링
   - 종료일 검증 로직
   - 종료일까지만 반복 일정 생성
   - 에러 메시지 표시

2. 🟡 **Important** (4개)

   - 종료일 없는 무제한 반복
   - 100개 제한 경고
   - 생성된 일정 개수 표시
   - 일정 목록에서 종료일 표시

3. 🟢 **Nice to have** (2개)
   - 빈 문자열 종료일 처리
   - 일정 수정 시 반복 정보 유지

---

## 📝 테스트 케이스

### 1️⃣ 단위 테스트: 반복 종료일 검증 함수

#### 테스트 케이스 1.1: 종료일이 시작일보다 이후인 경우 (유효)

**우선순위**: 🔴 Critical

**Arrange** (준비)

- 시작일: "2025-11-01"
- 종료일: "2025-12-31"
- 최대 날짜: "2025-12-31"

**Act** (실행)

- `validateRepeatEndDate("2025-11-01", "2025-12-31", "2025-12-31")` 호출

**Assert** (검증)

- 반환값이 `null` 이다 (에러 없음)

**테스트 파일**: `src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`

---

#### 테스트 케이스 1.2: 종료일이 시작일보다 이전인 경우 (에러)

**우선순위**: 🔴 Critical

**Arrange** (준비)

- 시작일: "2025-11-10"
- 종료일: "2025-11-05"
- 최대 날짜: "2025-12-31"

**Act** (실행)

- `validateRepeatEndDate("2025-11-10", "2025-11-05", "2025-12-31")` 호출

**Assert** (검증)

- 반환값이 `"종료일은 시작일 이후여야 합니다"` 이다

**테스트 파일**: `src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`

---

#### 테스트 케이스 1.3: 종료일이 시작일과 같은 경우 (에러)

**우선순위**: 🟡 Important

**Arrange** (준비)

- 시작일: "2025-11-10"
- 종료일: "2025-11-10"
- 최대 날짜: "2025-12-31"

**Act** (실행)

- `validateRepeatEndDate("2025-11-10", "2025-11-10", "2025-12-31")` 호출

**Assert** (검증)

- 반환값이 `"종료일은 시작일 이후여야 합니다"` 이다

**테스트 파일**: `src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`

---

#### 테스트 케이스 1.4: 종료일이 최대 날짜보다 이후인 경우 (에러)

**우선순위**: 🔴 Critical

**Arrange** (준비)

- 시작일: "2025-11-01"
- 종료일: "2026-01-01"
- 최대 날짜: "2025-12-31"

**Act** (실행)

- `validateRepeatEndDate("2025-11-01", "2026-01-01", "2025-12-31")` 호출

**Assert** (검증)

- 반환값이 `"종료일은 2025-12-31 이전이어야 합니다"` 이다

**테스트 파일**: `src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`

---

#### 테스트 케이스 1.5: 종료일이 비어있는 경우 (유효 - 무제한 반복)

**우선순위**: 🟡 Important

**Arrange** (준비)

- 시작일: "2025-11-01"
- 종료일: "" (빈 문자열)
- 최대 날짜: "2025-12-31"

**Act** (실행)

- `validateRepeatEndDate("2025-11-01", "", "2025-12-31")` 호출

**Assert** (검증)

- 반환값이 `null` 이다 (에러 없음 - 무제한 반복 허용)

**테스트 파일**: `src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`

---

#### 테스트 케이스 1.6: 종료일이 최대 날짜와 같은 경우 (유효)

**우선순위**: 🟡 Important

**Arrange** (준비)

- 시작일: "2025-11-01"
- 종료일: "2025-12-31"
- 최대 날짜: "2025-12-31"

**Act** (실행)

- `validateRepeatEndDate("2025-11-01", "2025-12-31", "2025-12-31")` 호출

**Assert** (검증)

- 반환값이 `null` 이다 (에러 없음 - 경계값 허용)

**테스트 파일**: `src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`

---

### 2️⃣ 통합 테스트: 반복 설정 UI 및 일정 생성

#### 테스트 케이스 2.1: 반복 체크박스 체크 시 반복 설정 UI 표시

**우선순위**: 🔴 Critical

**Arrange** (준비)

- App 컴포넌트 렌더링
- userEvent 설정
- 반복 체크박스가 체크되지 않은 상태

**Act** (실행)

- 사용자가 "반복 일정" 체크박스를 클릭
- `await user.click(screen.getByRole('checkbox', { name: /반복 일정/i }))`

**Assert** (검증)

- 반복 유형 선택 필드가 표시된다
  - `expect(screen.getByLabelText(/반복 유형/i)).toBeInTheDocument()`
- 반복 간격 입력 필드가 표시된다
  - `expect(screen.getByLabelText(/반복 간격/i)).toBeInTheDocument()`
- 반복 종료일 입력 필드가 표시된다
  - `expect(screen.getByLabelText(/반복 종료일/i)).toBeInTheDocument()`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/i });
const repeatTypeSelect = screen.getByLabelText(/반복 유형/i);
const repeatIntervalInput = screen.getByLabelText(/반복 간격/i);
const repeatEndDateInput = screen.getByLabelText(/반복 종료일/i);
```

---

#### 테스트 케이스 2.2: 반복 체크박스 해제 시 반복 설정 UI 숨김

**우선순위**: 🟡 Important

**Arrange** (준비)

- App 컴포넌트 렌더링
- 반복 체크박스가 체크된 상태
- 반복 설정 UI가 표시된 상태

**Act** (실행)

- 사용자가 "반복 일정" 체크박스를 다시 클릭 (해제)

**Assert** (검증)

- 반복 유형 선택 필드가 숨겨진다
  - `expect(screen.queryByLabelText(/반복 유형/i)).not.toBeInTheDocument()`
- 반복 간격 입력 필드가 숨겨진다
  - `expect(screen.queryByLabelText(/반복 간격/i)).not.toBeInTheDocument()`
- 반복 종료일 입력 필드가 숨겨진다
  - `expect(screen.queryByLabelText(/반복 종료일/i)).not.toBeInTheDocument()`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

#### 테스트 케이스 2.3: 반복 종료일 필드에 최대 날짜 제한 설정 확인

**우선순위**: 🔴 Critical

**Arrange** (준비)

- App 컴포넌트 렌더링
- 반복 체크박스 체크
- 반복 설정 UI 표시됨

**Act** (실행)

- 반복 종료일 입력 필드 찾기

**Assert** (검증)

- 반복 종료일 입력 필드의 `max` 속성이 "2025-12-31"이다
  - `expect(repeatEndDateInput).toHaveAttribute('max', '2025-12-31')`
- type이 "date"이다
  - `expect(repeatEndDateInput).toHaveAttribute('type', 'date')`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

#### 테스트 케이스 2.4: 종료일이 시작일보다 이전인 경우 에러 메시지 표시

**우선순위**: 🔴 Critical

**Arrange** (준비)

- App 컴포넌트 렌더링
- MSW가 POST /api/events-list를 모킹하지 않음 (호출되지 않아야 함)

**Act** (실행)

- 사용자가 일정 정보 입력:
  - 제목: "주간 회의"
  - 날짜: "2025-11-10" (시작일)
  - 시작 시간: "14:00"
  - 종료 시간: "15:00"
- 반복 체크박스 체크
- 반복 유형: "매주" 선택
- 반복 간격: 1 입력
- 반복 종료일: "2025-11-05" 입력 (시작일보다 이전)
- "일정 추가" 버튼 클릭

**Assert** (검증)

- Snackbar에 에러 메시지가 표시된다
  - `await screen.findByText(/종료일은 시작일 이후여야 합니다/i)`
- API 호출이 발생하지 않는다
  - `expect(mockPostApi).not.toHaveBeenCalled()`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**Mock 전략**:

```typescript
// MSW 핸들러는 설정하지 않음
// API 호출이 없어야 하므로 spy로만 감시
const mockPostApi = vi.fn();
```

---

#### 테스트 케이스 2.5: 종료일이 있는 반복 일정 생성 - 종료일까지만 생성됨

**우선순위**: 🔴 Critical

**Arrange** (준비)

- App 컴포넌트 렌더링
- MSW가 POST /api/events-list를 모킹하여 반복 일정 배열 저장
- 현재 날짜: 2025-11-01 (vitest fake timers)

**Act** (실행)

- 사용자가 일정 정보 입력:
  - 제목: "매주 운동"
  - 날짜: "2025-11-01" (토요일)
  - 시작 시간: "10:00"
  - 종료 시간: "11:00"
- 반복 체크박스 체크
- 반복 유형: "매주" 선택
- 반복 간격: 1 입력
- 반복 종료일: "2025-11-30" 입력
- "일정 추가" 버튼 클릭

**Assert** (검증)

- POST /api/events-list가 호출된다
- 요청 body의 events 배열 길이가 5개이다 (11/1, 11/8, 11/15, 11/22, 11/29)
  - 11월 토요일 5개 (11/30은 일요일이므로 제외)
- Snackbar에 성공 메시지가 표시된다
  - `await screen.findByText(/5개의 반복 일정이 생성되었습니다/i)`
- 각 일정의 날짜가 종료일(2025-11-30) 이전이다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**Mock 전략**:

```typescript
// MSW 핸들러
http.post('/api/events-list', async ({ request }) => {
  const { events } = await request.json();
  // events 배열 검증 가능하도록 저장
  return HttpResponse.json({ success: true });
});

// Fake timers
vi.useFakeTimers();
vi.setSystemTime(new Date('2025-11-01T00:00:00Z'));
```

---

#### 테스트 케이스 2.6: 종료일 없는 반복 일정 - 최대 100개까지 생성

**우선순위**: 🟡 Important

**Arrange** (준비)

- App 컴포넌트 렌더링
- MSW가 POST /api/events-list를 모킹
- 현재 날짜: 2025-01-01

**Act** (실행)

- 사용자가 일정 정보 입력:
  - 제목: "매일 알림"
  - 날짜: "2025-01-01"
  - 시작 시간: "09:00"
  - 종료 시간: "09:30"
- 반복 체크박스 체크
- 반복 유형: "매일" 선택
- 반복 간격: 1 입력
- 반복 종료일: 비워둠 (빈 문자열)
- "일정 추가" 버튼 클릭

**Assert** (검증)

- POST /api/events-list가 호출된다
- 요청 body의 events 배열 길이가 100개이다 (최대 제한)
- Snackbar에 경고 메시지가 표시된다
  - `await screen.findByText(/반복 일정이 너무 많아 100개까지만 생성되었습니다/i)`
- 성공 메시지도 함께 표시된다
  - `await screen.findByText(/100개의 반복 일정이 생성되었습니다/i)`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

#### 테스트 케이스 2.7: 일정 목록에서 반복 종료일 정보 표시

**우선순위**: 🟡 Important

**Arrange** (준비)

- App 컴포넌트 렌더링
- MSW가 GET /api/events를 모킹하여 반복 일정 반환:
  ```typescript
  {
    id: '1',
    title: '주간 회의',
    repeat: {
      type: 'weekly',
      interval: 2,
      endDate: '2025-12-31'
    },
    // ... 기타 필드
  }
  ```

**Act** (실행)

- 초기 렌더링 후 일정 목록 로드 대기

**Assert** (검증)

- 일정 목록에서 반복 정보가 표시된다
  - `expect(screen.getByText(/반복: 2주마다 \(종료: 2025-12-31\)/i)).toBeInTheDocument()`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
const eventList = screen.getByTestId('event-list');
const repeatInfo = within(eventList).getByText(/반복:.*종료:/i);
```

---

#### 테스트 케이스 2.8: 일정 목록에서 종료일 없는 반복 일정 표시

**우선순위**: 🟡 Important

**Arrange** (준비)

- App 컴포넌트 렌더링
- MSW가 GET /api/events를 모킹하여 반복 일정 반환:
  ```typescript
  {
    id: '2',
    title: '매일 운동',
    repeat: {
      type: 'daily',
      interval: 1,
      endDate: undefined
    },
    // ... 기타 필드
  }
  ```

**Act** (실행)

- 초기 렌더링 후 일정 목록 로드 대기

**Assert** (검증)

- 일정 목록에서 반복 정보가 표시된다
  - `expect(screen.getByText(/반복: 1일마다$/i)).toBeInTheDocument()`
- 종료일 정보가 표시되지 않는다
  - `expect(screen.queryByText(/종료:/i)).not.toBeInTheDocument()`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

### 3️⃣ 엣지 케이스 테스트

#### 테스트 케이스 3.1: 종료일까지 1개의 일정만 생성되는 경우

**우선순위**: 🟢 Nice to have

**Arrange** (준비)

- App 컴포넌트 렌더링
- MSW가 POST /api/events-list를 모킹

**Act** (실행)

- 사용자가 일정 정보 입력:
  - 제목: "특별 회의"
  - 날짜: "2025-12-30" (월요일)
  - 시작 시간: "14:00"
  - 종료 시간: "15:00"
- 반복 체크박스 체크
- 반복 유형: "매주" 선택
- 반복 간격: 1 입력
- 반복 종료일: "2025-12-31" 입력 (다음 월요일은 2026-01-06)
- "일정 추가" 버튼 클릭

**Assert** (검증)

- POST /api/events-list가 호출된다
- 요청 body의 events 배열 길이가 1개이다 (시작일만)
- Snackbar에 성공 메시지가 표시된다
  - `await screen.findByText(/1개의 반복 일정이 생성되었습니다/i)`

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

#### 테스트 케이스 3.2: 빈 문자열 종료일 처리 (무제한 반복으로 간주)

**우선순위**: 🟢 Nice to have

**Arrange** (준비)

- App 컴포넌트 렌더링
- 반복 종료일 입력 후 다시 삭제하여 빈 문자열로 만듦

**Act** (실행)

- 사용자가 반복 종료일에 "2025-12-31" 입력
- 사용자가 입력 필드를 클리어하여 빈 문자열로 만듦
- "일정 추가" 버튼 클릭

**Assert** (검증)

- 에러 메시지가 표시되지 않는다
- 반복 일정 생성 API가 호출된다
- 최대 100개까지 생성됨

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

---

## 🧪 테스트 데이터 정의

### Mock 데이터

```typescript
// 반복 일정 Mock 데이터
export const mockRepeatEvent = {
  id: '1',
  title: '주간 회의',
  date: '2025-11-01',
  startTime: '14:00',
  endTime: '15:00',
  description: '프로젝트 리뷰',
  location: '회의실 A',
  category: '업무',
  repeat: {
    type: 'weekly' as const,
    interval: 1,
    endDate: '2025-12-31',
  },
  notificationTime: 10,
};

// 종료일 없는 반복 일정
export const mockUnlimitedRepeatEvent = {
  ...mockRepeatEvent,
  id: '2',
  title: '매일 운동',
  repeat: {
    type: 'daily' as const,
    interval: 1,
    endDate: undefined,
  },
};

// 반복 일정 배열 (생성 결과)
export const mockGeneratedRepeatEvents = [
  { ...mockRepeatEvent, date: '2025-11-01' },
  { ...mockRepeatEvent, date: '2025-11-08' },
  { ...mockRepeatEvent, date: '2025-11-15' },
  { ...mockRepeatEvent, date: '2025-11-22' },
  { ...mockRepeatEvent, date: '2025-11-29' },
];
```

### Fixture 데이터

```typescript
// 검증 함수 테스트 데이터
export const validationTestCases = {
  valid: {
    startDate: '2025-11-01',
    endDate: '2025-12-31',
    maxDate: '2025-12-31',
  },
  endDateBeforeStartDate: {
    startDate: '2025-11-10',
    endDate: '2025-11-05',
    maxDate: '2025-12-31',
    expectedError: '종료일은 시작일 이후여야 합니다',
  },
  endDateAfterMaxDate: {
    startDate: '2025-11-01',
    endDate: '2026-01-01',
    maxDate: '2025-12-31',
    expectedError: '종료일은 2025-12-31 이전이어야 합니다',
  },
  emptyEndDate: {
    startDate: '2025-11-01',
    endDate: '',
    maxDate: '2025-12-31',
  },
};
```

---

## 🎭 Mock/Stub 전략

### API Mocking (MSW)

```typescript
// GET /api/events - 반복 일정 포함
http.get('/api/events', () => {
  return HttpResponse.json({
    events: [mockRepeatEvent, mockUnlimitedRepeatEvent],
  });
});

// POST /api/events-list - 반복 일정 배열 생성
http.post('/api/events-list', async ({ request }) => {
  const { events } = await request.json();

  // 테스트에서 events 배열 검증 가능
  return HttpResponse.json({
    success: true,
    message: `${events.length}개의 반복 일정이 생성되었습니다`,
  });
});
```

### Time Mocking

```typescript
// 테스트 시작 시간 고정
vi.useFakeTimers();
vi.setSystemTime(new Date('2025-11-01T00:00:00Z'));

// 테스트 완료 후 복원
afterEach(() => {
  vi.useRealTimers();
});
```

### 컴포넌트 Mocking

이 기능은 기존 App 컴포넌트 내에서 테스트하므로 별도 컴포넌트 mocking 불필요

---

## 📁 테스트 파일 구조

```
src/__tests__/
  └── unit/
      └── easy.repeatEndDateValidation.spec.ts  # 종료일 검증 함수
  └── medium.integration.spec.tsx                # 통합 테스트 (기존 파일 확장)
```

### 예상 테스트 파일 목록

1. **`src/__tests__/unit/easy.repeatEndDateValidation.spec.ts`** (신규)

   - 반복 종료일 검증 함수 단위 테스트
   - 6개 테스트 케이스
   - 예상 LOC: ~80줄

2. **`src/__tests__/medium.integration.spec.tsx`** (기존 파일 확장)
   - 반복 설정 UI 통합 테스트
   - 8개 테스트 케이스 추가
   - 예상 추가 LOC: ~300줄

---

## 🎯 React Testing Library 쿼리 전략

### 사용할 쿼리 (우선순위 순)

#### 1. getByRole (최우선)

```typescript
// 체크박스
const repeatCheckbox = screen.getByRole('checkbox', { name: /반복 일정/i });

// 버튼
const submitButton = screen.getByRole('button', { name: /일정 추가/i });

// Select (combobox)
const repeatTypeSelect = screen.getByRole('combobox', { name: /반복 유형/i });
```

#### 2. getByLabelText (폼 요소)

```typescript
// 텍스트 입력
const titleInput = screen.getByLabelText(/제목/i);
const dateInput = screen.getByLabelText(/날짜/i);

// 날짜 입력
const repeatEndDateInput = screen.getByLabelText(/반복 종료일/i);

// 숫자 입력
const repeatIntervalInput = screen.getByLabelText(/반복 간격/i);
```

#### 3. getByText (텍스트 콘텐츠)

```typescript
// Snackbar 메시지
const errorMessage = await screen.findByText(/종료일은 시작일 이후여야 합니다/i);
const successMessage = await screen.findByText(/5개의 반복 일정이 생성되었습니다/i);

// 일정 목록 텍스트
const repeatInfo = screen.getByText(/반복: 2주마다 \(종료: 2025-12-31\)/i);
```

#### 4. getByTestId (최후의 수단)

```typescript
// 기존 코드에 이미 있는 경우만 사용
const eventList = screen.getByTestId('event-list');
const submitButton = screen.getByTestId('event-submit-button');
```

### 비동기 처리

```typescript
// findBy: 비동기로 나타날 요소 (Snackbar 등)
const successMessage = await screen.findByText(/생성되었습니다/i);

// waitFor: 복잡한 조건 대기 (API 호출 확인)
await waitFor(() => {
  expect(mockPostApi).toHaveBeenCalledWith(
    expect.objectContaining({
      events: expect.arrayContaining([expect.objectContaining({ date: '2025-11-01' })]),
    })
  );
});

// waitForElementToBeRemoved: 로딩 사라짐 대기
await waitForElementToBeRemoved(() => screen.queryByText(/로딩중/i));
```

---

## ⚠️ 엣지 케이스 테스트

### 1. 종료일이 시작일보다 이전

- **시나리오**: 사용자가 실수로 과거 날짜를 종료일로 입력
- **검증 항목**:
  - 에러 메시지 "종료일은 시작일 이후여야 합니다" 표시
  - API 호출 발생하지 않음
  - 일정 생성 안 됨

### 2. 종료일이 최대 날짜보다 이후

- **시나리오**: 2025-12-31보다 이후 날짜 입력 시도
- **검증 항목**:
  - HTML5 date input의 `max` 속성으로 브라우저가 제한
  - 직접 입력 시 에러 메시지 표시
  - API 호출 발생하지 않음

### 3. 종료일 없음 (무제한 반복)

- **시나리오**: 종료일 필드를 비워두고 일정 생성
- **검증 항목**:
  - 최대 100개까지 반복 일정 생성
  - 경고 메시지 "반복 일정이 너무 많아 100개까지만 생성되었습니다" 표시
  - 100개 일정 모두 생성됨

### 4. 종료일까지 1개만 생성

- **시나리오**: 시작일과 종료일 사이에 반복 조건을 만족하는 날짜가 없음
- **검증 항목**:
  - 시작일 1개만 일정 생성
  - "1개의 반복 일정이 생성되었습니다" 메시지 표시

### 5. 빈 문자열 종료일

- **시나리오**: 날짜 입력 후 삭제하여 빈 문자열로 만듦
- **검증 항목**:
  - 무제한 반복으로 간주
  - 검증 에러 발생하지 않음
  - 최대 100개까지 생성

### 6. 매월 반복 시 존재하지 않는 날짜

- **시나리오**: 1월 31일 시작, 매월 반복, 종료일 12월 31일
- **검증 항목**:
  - 31일이 없는 달은 건너뛰기
  - `generateRepeatEvents` 함수가 이미 처리 (기존 구현 활용)

### 7. 윤년 2월 29일 매년 반복

- **시나리오**: 2024-02-29 시작, 매년 반복
- **검증 항목**:
  - 윤년에만 생성 (2024, 2028)
  - `generateRepeatEvents` 함수가 이미 처리 (기존 구현 활용)

### 8. 일정 수정 시 반복 정보 유지

- **시나리오**: 반복 일정 수정 모드로 진입
- **검증 항목**:
  - 반복 체크박스가 체크된 상태로 표시
  - 반복 설정 UI가 표시됨
  - 기존 종료일이 입력 필드에 표시됨
  - `useEventForm`의 `editEvent` 함수가 이미 처리 (확인 필요)

---

## 🚨 에러 처리 테스트

### 1. 종료일 검증 실패

- **발생 조건**:
  - 종료일 < 시작일
  - 종료일 > 최대 날짜
- **예상 동작**:
  - Snackbar에 에러 메시지 표시
  - 일정 생성 API 호출 안 됨
- **검증 방법**:
  - `await screen.findByText(/에러 메시지/i)`
  - `expect(mockPostApi).not.toHaveBeenCalled()`

### 2. 반복 일정 생성 API 실패

- **발생 조건**: POST /api/events-list가 500 에러 반환
- **예상 동작**:
  - "반복 일정 생성에 실패했습니다. 다시 시도해주세요." 메시지 표시
  - 기존 일정 목록 유지
- **검증 방법**:
  - MSW로 에러 응답 설정
  - 에러 메시지 확인

### 3. 네트워크 오류

- **발생 조건**: 네트워크 연결 실패
- **예상 동작**:
  - 일반 에러 메시지 표시
  - 재시도 가능
- **검증 방법**:
  - MSW로 네트워크 에러 모킹
  - 에러 핸들링 확인

---

## 📋 테스트 체크리스트

### 테스트 작성 전

- [x] 기능 명세서 검토 완료
- [x] 테스트 케이스가 인수 조건 13개를 모두 커버하는가?
  - UI 활성화: 4개 → 3개 테스트 케이스
  - 검증: 4개 → 6개 테스트 케이스 (단위 테스트)
  - 생성: 3개 → 2개 테스트 케이스
  - 표시: 2개 → 2개 테스트 케이스
- [x] Mock 전략이 명확한가?
  - MSW: GET /api/events, POST /api/events-list
  - Vitest fake timers
- [x] 테스트 데이터가 준비되었는가?
  - mockRepeatEvent, validationTestCases 정의

### 테스트 작성 중

- [ ] AAA 패턴을 따르는가?
- [ ] 접근성 쿼리를 우선 사용하는가? (getByRole > getByLabelText)
- [ ] userEvent를 사용하는가?
- [ ] 비동기 처리가 적절한가? (findBy, waitFor)

### 테스트 작성 후

- [ ] 모든 테스트가 실패하는가? (RED 단계 - TDD)
- [ ] 테스트 이름이 명확한가?
- [ ] 중복 코드가 없는가?
- [ ] 테스트가 독립적으로 실행 가능한가?

---

## 📊 테스트 커버리지 목표

### 인수 조건 커버리지

- **총 인수 조건**: 13개
- **커버하는 테스트 케이스**: 14개 (100% 커버 + 추가 엣지 케이스)
- **커버리지**: 100%

### 엣지 케이스 커버리지

- **명세서 엣지 케이스**: 8개
- **커버하는 테스트 케이스**: 8개
- **커버리지**: 100%

### 예상 테스트 통계

- **단위 테스트**: 6개 (easy.repeatEndDateValidation.spec.ts)
- **통합 테스트**: 8개 (medium.integration.spec.tsx에 추가)
- **총 테스트 케이스**: 14개
- **예상 실행 시간**: ~5초

---

## 📚 참고 문서

- **TDD 워크플로우 가이드**: `docs/tdd-workflow-guide.md`
- **프로젝트 구조**: `bmad-tdd/core/index.mdc`
- **React 베스트 프랙티스**: `bmad-tdd/core/rules/react.mdc`
- **기존 테스트 패턴**:
  - `src/__tests__/unit/easy.timeValidation.spec.ts` (유사한 검증 함수 테스트)
  - `src/__tests__/medium.integration.spec.tsx` (통합 테스트 패턴)

---

## ✅ 테스트 파일 구조 상세

### 1. easy.repeatEndDateValidation.spec.ts

```typescript
describe('validateRepeatEndDate >', () => {
  describe('유효한 경우 >', () => {
    it('종료일이 시작일보다 이후인 경우 null을 반환한다', () => {
      // ...
    });

    it('종료일이 비어있는 경우 null을 반환한다 (무제한 반복)', () => {
      // ...
    });

    it('종료일이 최대 날짜와 같은 경우 null을 반환한다', () => {
      // ...
    });
  });

  describe('에러 케이스 >', () => {
    it('종료일이 시작일보다 이전인 경우 에러 메시지를 반환한다', () => {
      // ...
    });

    it('종료일이 시작일과 같은 경우 에러 메시지를 반환한다', () => {
      // ...
    });

    it('종료일이 최대 날짜보다 이후인 경우 에러 메시지를 반환한다', () => {
      // ...
    });
  });
});
```

### 2. medium.integration.spec.tsx (추가 describe 블록)

```typescript
describe('반복 일정 종료 조건 설정', () => {
  describe('반복 설정 UI', () => {
    it('반복 체크박스 체크 시 반복 설정 UI가 표시된다', async () => {
      // ...
    });

    it('반복 체크박스 해제 시 반복 설정 UI가 숨겨진다', async () => {
      // ...
    });

    it('반복 종료일 필드에 최대 날짜 제한이 설정되어 있다', async () => {
      // ...
    });
  });

  describe('반복 종료일 검증', () => {
    it('종료일이 시작일보다 이전인 경우 에러 메시지가 표시된다', async () => {
      // ...
    });
  });

  describe('반복 일정 생성', () => {
    it('종료일이 있는 반복 일정은 종료일까지만 생성된다', async () => {
      // ...
    });

    it('종료일 없는 반복 일정은 최대 100개까지 생성된다', async () => {
      // ...
    });

    it('종료일까지 1개의 일정만 생성되는 경우를 처리한다', async () => {
      // ...
    });
  });

  describe('반복 일정 표시', () => {
    it('일정 목록에서 반복 종료일 정보가 표시된다', async () => {
      // ...
    });

    it('종료일 없는 반복 일정은 종료일 정보를 표시하지 않는다', async () => {
      // ...
    });
  });
});
```

---

## 🎯 중요 구현 노트

### 1. 검증 함수 위치

`validateRepeatEndDate` 함수는 `src/utils/repeatEndDateValidation.ts`에 신규 생성하거나, 간단한 로직이므로 `src/App.tsx`의 `addOrUpdateEvent` 함수 내에서 인라인으로 검증할 수도 있습니다.

**권장**: 별도 파일로 분리하여 테스트 가능하고 재사용 가능하도록 구현

### 2. UI 활성화 방법

`src/App.tsx` 441-478줄의 주석을 제거하기만 하면 됩니다. 추가로:

- 469줄 반복 종료일 TextField에 `slotProps={{ htmlInput: { max: '2025-12-31' } }}` 추가

### 3. 기존 로직 활용

- `generateRepeatEvents` 함수는 이미 `endDate`를 처리하므로 수정 불필요
- `useEventOperations`의 `createRepeatEvents` 함수도 이미 구현되어 있음
- 새로 추가할 것은 검증 로직뿐

### 4. 테스트 작성 순서 (TDD RED 단계)

1. **단위 테스트 먼저**: `easy.repeatEndDateValidation.spec.ts` 작성
   - 6개 테스트 케이스 모두 실패 확인
2. **통합 테스트**: `medium.integration.spec.tsx` 확장
   - UI 테스트부터 작성
   - 반복 일정 생성 테스트 작성
   - 모두 실패 확인

---

## 📈 예상 작업 시간

- **테스트 설계 검토**: 10분
- **단위 테스트 코드 작성**: 20분
- **통합 테스트 코드 작성**: 40분
- **테스트 실행 및 RED 확인**: 10분
- **총 예상 시간**: 1시간 20분

---

## 🔍 추가 검증 필요 사항

### 1. App.tsx의 주석 처리된 코드 확인

현재 441-478줄이 주석 처리되어 있는지 재확인 필요

### 2. useEventForm의 상태 관리 확인

`repeatEndDate` 상태가 이미 존재하는지 확인됨 (✅ 존재)

### 3. 일정 목록 표시 로직 확인

App.tsx 558-567줄에서 반복 정보를 이미 표시하고 있음 (✅ 확인)

---

## ✔️ 최종 체크리스트

- [x] 모든 인수 조건이 테스트 케이스로 변환되었는가? (13개 → 14개 케이스)
- [x] AAA 패턴을 모든 케이스에 적용했는가?
- [x] 접근성 쿼리 우선순위를 명시했는가? (getByRole > getByLabelText > getByText)
- [x] 엣지 케이스가 충분히 고려되었는가? (8개 모두 포함)
- [x] Mock 전략이 명확한가? (MSW, fake timers)
- [x] 테스트 데이터가 정의되었는가? (mockRepeatEvent, validationTestCases)
- [x] 비동기 처리 방법이 명시되었는가? (findBy, waitFor)
- [x] 기존 프로젝트 테스트 패턴과 일치하는가? (describe > it 구조)
- [x] 테스트 파일 경로가 명확한가? (unit/, medium.integration)
- [x] TDD RED 단계 진행 가능한가? (모든 테스트가 실패해야 함)

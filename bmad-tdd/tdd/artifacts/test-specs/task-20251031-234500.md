# 테스트 설계 명세서: 반복 일정 수정

## 📋 기본 정보

- **Task ID**: task-20251031-234500
- **작성일**: 2025-10-31
- **작성자**: Test Designer Agent
- **기능 명세서**: `bmad-tdd/tdd/artifacts/features/task-20251031-234500.md`

---

## 🎯 테스트 전략

### 테스트 범위

- **단위 테스트**: 없음 (이 기능은 UI 인터랙션과 상태 관리가 주요 내용)
- **통합 테스트**: App 컴포넌트 + Dialog + useEventOperations 통합 테스트
  - 반복 일정 수정 시 다이얼로그 표시
  - 다이얼로그 버튼 클릭에 따른 동작 분기
  - API 호출 및 UI 업데이트
- **E2E 테스트**: 불필요 (통합 테스트로 충분)

### 테스트 우선순위

1. 🔴 **Critical** (6개):

   - 반복 일정 수정 시 다이얼로그 표시
   - "예" 버튼 클릭 시 단일 일정으로 변경
   - "아니오" 버튼 클릭 시 반복 정보 유지
   - "취소" 버튼 클릭 시 수정 취소
   - 단일 일정 수정 시 다이얼로그 미표시
   - API 요청 실패 시 에러 처리

2. 🟡 **Important** (3개):

   - 다이얼로그 UI 요소 검증
   - 반복일정 아이콘 표시/숨김
   - 성공 메시지 표시

3. 🟢 **Nice to have** (2개):
   - 겹침 경고와의 연동
   - 취소 후 재시도

---

## 📝 테스트 케이스

### 테스트 케이스 1: 반복 일정 수정 시 다이얼로그 표시

**우선순위**: Critical

**Arrange** (준비)

- App 컴포넌트가 렌더링됨
- 반복 일정이 존재함 (`repeat.type: 'daily'`)
- MSW가 PUT `/api/events/:id` 엔드포인트를 모킹하여 성공 응답 반환

**Act** (실행)

- 사용자가 반복 일정의 "Edit event" 버튼 클릭
- 일정 제목을 수정 (예: "팀 회의" → "수정된 팀 회의")
- 일정 저장 버튼 클릭

**Assert** (검증)

- "반복 일정 수정" 다이얼로그가 표시된다
- 다이얼로그 제목: "반복 일정 수정"
- 다이얼로그 내용: "해당 일정만 수정하시겠어요?"
- "취소" 버튼이 표시된다
- "예" 버튼이 표시된다
- "아니오" 버튼이 표시된다
- API 요청이 아직 발생하지 않는다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// 다이얼로그 찾기
const dialog = screen.getByRole('dialog');
expect(within(dialog).getByText('반복 일정 수정')).toBeInTheDocument();
expect(within(dialog).getByText('해당 일정만 수정하시겠어요?')).toBeInTheDocument();

// 버튼 찾기
const cancelButton = within(dialog).getByRole('button', { name: '취소' });
const yesButton = within(dialog).getByRole('button', { name: '예' });
const noButton = within(dialog).getByRole('button', { name: '아니오' });
```

---

### 테스트 케이스 2: "예" 버튼 클릭 시 단일 일정으로 변경

**우선순위**: Critical

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태
- 수정할 일정 데이터가 준비됨 (제목: "수정된 팀 회의", `repeat.type: 'daily'`)
- MSW가 PUT 요청을 모킹하여 성공 응답 반환

**Act** (실행)

- 사용자가 다이얼로그에서 "예" 버튼 클릭

**Assert** (검증)

- 다이얼로그가 닫힌다
- PUT `/api/events/:id` 요청이 다음 데이터로 호출된다:
  - `repeat.type: 'none'`
  - `repeat.interval: 1`
  - `repeat.endDate: undefined`
- "일정이 수정되었습니다." 성공 메시지가 표시된다
- 일정 목록에서 반복일정 아이콘이 사라진다
- 수정된 제목 "수정된 팀 회의"가 일정 목록에 표시된다
- 폼이 초기화된다 (편집 모드 해제)

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// "예" 버튼 클릭
const yesButton = within(dialog).getByRole('button', { name: '예' });
await user.click(yesButton);

// 다이얼로그 닫힘 확인
await waitFor(() => {
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});

// API 호출 확인 (MSW 핸들러에서 검증)
// 성공 메시지 확인
expect(await screen.findByText('일정이 수정되었습니다.')).toBeInTheDocument();

// 반복일정 아이콘 사라짐 확인
const eventList = screen.getByTestId('event-list');
expect(within(eventList).queryByRole('img', { name: /반복 일정/ })).not.toBeInTheDocument();
```

---

### 테스트 케이스 3: "아니오" 버튼 클릭 시 반복 정보 유지

**우선순위**: Critical

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태
- 수정할 일정 데이터가 준비됨 (제목: "수정된 요가", `repeat.type: 'weekly'`, `repeat.interval: 1`)
- MSW가 PUT 요청을 모킹하여 성공 응답 반환

**Act** (실행)

- 사용자가 다이얼로그에서 "아니오" 버튼 클릭

**Assert** (검증)

- 다이얼로그가 닫힌다
- PUT `/api/events/:id` 요청이 다음 데이터로 호출된다:
  - `repeat.type: 'weekly'` (원본 유지)
  - `repeat.interval: 1` (원본 유지)
  - 기존 반복 정보 그대로 전송
- "일정이 수정되었습니다." 성공 메시지가 표시된다
- 일정 목록에서 반복일정 아이콘이 여전히 표시된다
- 수정된 제목 "수정된 요가"가 일정 목록에 표시된다
- 폼이 초기화된다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// "아니오" 버튼 클릭
const noButton = within(dialog).getByRole('button', { name: '아니오' });
await user.click(noButton);

// 다이얼로그 닫힘 확인
await waitFor(() => {
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});

// 성공 메시지 확인
expect(await screen.findByText('일정이 수정되었습니다.')).toBeInTheDocument();

// 반복일정 아이콘 유지 확인
const eventList = screen.getByTestId('event-list');
expect(within(eventList).getByRole('img', { name: /반복 일정/ })).toBeInTheDocument();
```

---

### 테스트 케이스 4: "취소" 버튼 클릭 시 수정 취소

**우선순위**: Critical

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태
- 수정할 일정 데이터가 준비됨

**Act** (실행)

- 사용자가 다이얼로그에서 "취소" 버튼 클릭

**Assert** (검증)

- 다이얼로그가 닫힌다
- API 요청이 발생하지 않는다
- 폼이 그대로 유지된다 (편집 모드 유지)
- 일정 목록에 변경사항이 없다
- 성공/에러 메시지가 표시되지 않는다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// "취소" 버튼 클릭
const cancelButton = within(dialog).getByRole('button', { name: '취소' });
await user.click(cancelButton);

// 다이얼로그 닫힘 확인
await waitFor(() => {
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});

// 폼이 여전히 채워져 있는지 확인
expect(screen.getByLabelText('제목')).toHaveValue('수정된 팀 회의');

// API 호출 없음 확인 (MSW 핸들러에서 호출 횟수 검증)
```

---

### 테스트 케이스 5: 단일 일정 수정 시 다이얼로그 미표시

**우선순위**: Critical

**Arrange** (준비)

- App 컴포넌트가 렌더링됨
- 단일 일정이 존재함 (`repeat.type: 'none'`)
- MSW가 PUT `/api/events/:id` 엔드포인트를 모킹하여 성공 응답 반환

**Act** (실행)

- 사용자가 단일 일정의 "Edit event" 버튼 클릭
- 일정 제목을 수정 (예: "회의" → "수정된 회의")
- 일정 저장 버튼 클릭

**Assert** (검증)

- 다이얼로그가 표시되지 않는다
- PUT `/api/events/:id` 요청이 즉시 호출된다
- "일정이 수정되었습니다." 성공 메시지가 표시된다
- 수정된 제목이 일정 목록에 표시된다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// 다이얼로그가 표시되지 않음 확인
expect(screen.queryByRole('dialog')).not.toBeInTheDocument();

// 성공 메시지 즉시 표시
expect(await screen.findByText('일정이 수정되었습니다.')).toBeInTheDocument();
```

---

### 테스트 케이스 6: API 요청 실패 시 에러 처리

**우선순위**: Critical

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태
- MSW가 PUT 요청을 모킹하여 500 에러 응답 반환

**Act** (실행)

- 사용자가 다이얼로그에서 "예" 버튼 클릭

**Assert** (검증)

- 다이얼로그가 닫힌다
- "일정 저장 실패" 에러 메시지가 표시된다
- 폼이 유지되어 사용자가 다시 시도할 수 있다
- 일정 목록에 변경사항이 없다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// MSW 핸들러를 500 에러로 오버라이드
server.use(
  http.put('/api/events/:id', () => {
    return new HttpResponse(null, { status: 500 });
  })
);

// "예" 버튼 클릭
const yesButton = within(dialog).getByRole('button', { name: '예' });
await user.click(yesButton);

// 에러 메시지 확인
expect(await screen.findByText('일정 저장 실패')).toBeInTheDocument();
```

---

### 테스트 케이스 7: 다이얼로그 UI 요소 검증

**우선순위**: Important

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태

**Act** (실행)

- 없음 (렌더링 상태 검증)

**Assert** (검증)

- 다이얼로그가 role="dialog"로 표시된다
- 다이얼로그 제목이 heading으로 표시된다
- 버튼들이 올바른 순서로 표시된다 (취소, 예, 아니오)
- ESC 키를 누르면 취소 동작이 실행된다
- 배경 클릭 시 취소 동작이 실행된다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// 다이얼로그 role 검증
const dialog = screen.getByRole('dialog');

// 제목 heading 검증
expect(within(dialog).getByRole('heading', { name: '반복 일정 수정' })).toBeInTheDocument();

// ESC 키 테스트
await user.keyboard('{Escape}');
await waitFor(() => {
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});
```

---

### 테스트 케이스 8: 반복일정 아이콘 표시/숨김

**우선순위**: Important

**Arrange** (준비)

- 반복 일정이 존재하고 아이콘이 표시된 상태
- 반복 일정 수정 다이얼로그가 표시됨

**Act** (실행)

- 사용자가 "예" 버튼 클릭하여 단일 수정

**Assert** (검증)

- 수정 전: 반복일정 아이콘이 표시됨
- 수정 후: 반복일정 아이콘이 사라짐
- 아이콘의 aria-label 또는 role 속성으로 검증

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// 수정 전 아이콘 확인
const eventList = screen.getByTestId('event-list');
expect(within(eventList).getByRole('img', { name: /반복 일정/ })).toBeInTheDocument();

// "예" 버튼 클릭 후
await user.click(yesButton);

// 아이콘 사라짐 확인
await waitFor(() => {
  expect(within(eventList).queryByRole('img', { name: /반복 일정/ })).not.toBeInTheDocument();
});
```

---

### 테스트 케이스 9: 성공 메시지 표시

**우선순위**: Important

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태
- MSW가 성공 응답 반환

**Act** (실행)

- 사용자가 "예" 또는 "아니오" 버튼 클릭

**Assert** (검증)

- "일정이 수정되었습니다." 메시지가 Snackbar로 표시된다
- 메시지 variant: success
- 메시지는 자동으로 사라진다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// 성공 메시지 표시 확인
expect(await screen.findByText('일정이 수정되었습니다.')).toBeInTheDocument();

// variant 확인 (notistack의 success variant)
const snackbar = screen.getByText('일정이 수정되었습니다.').closest('[class*="notistack"]');
expect(snackbar).toHaveClass(/success/i);
```

---

### 테스트 케이스 10: 취소 후 재시도

**우선순위**: Nice to have

**Arrange** (준비)

- 반복 일정 수정 다이얼로그가 표시된 상태

**Act** (실행)

- 사용자가 "취소" 버튼 클릭
- 다시 저장 버튼 클릭

**Assert** (검증)

- 다이얼로그가 다시 표시된다
- 폼 데이터는 그대로 유지된다
- 사용자가 다시 선택할 수 있다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// 첫 번째 취소
await user.click(cancelButton);
await waitFor(() => {
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});

// 다시 저장 버튼 클릭
await user.click(screen.getByTestId('event-submit-button'));

// 다이얼로그 다시 표시
expect(screen.getByRole('dialog')).toBeInTheDocument();
```

---

### 테스트 케이스 11: 겹침 경고와의 연동

**우선순위**: Nice to have

**Arrange** (준비)

- 반복 일정 수정 중
- 수정하려는 시간대에 다른 일정이 이미 존재함

**Act** (실행)

- 사용자가 반복 일정 수정 다이얼로그에서 "예" 버튼 클릭

**Assert** (검증)

- 반복 일정 수정 다이얼로그가 닫힌다
- 겹침 경고 다이얼로그가 표시된다
- "다음 일정과 겹칩니다" 메시지가 표시된다
- 사용자가 "계속 진행" 선택 시 최종 저장된다

**테스트 파일**: `src/__tests__/medium.integration.spec.tsx`

**쿼리 전략**:

```typescript
// "예" 버튼 클릭
await user.click(yesButton);

// 반복 일정 다이얼로그 닫힘
await waitFor(() => {
  expect(screen.queryByText('반복 일정 수정')).not.toBeInTheDocument();
});

// 겹침 경고 다이얼로그 표시
expect(await screen.findByText('일정 겹침 경고')).toBeInTheDocument();
expect(screen.getByText(/다음 일정과 겹칩니다/)).toBeInTheDocument();

// "계속 진행" 클릭
await user.click(screen.getByRole('button', { name: '계속 진행' }));

// 최종 저장 확인
expect(await screen.findByText('일정이 수정되었습니다.')).toBeInTheDocument();
```

---

## 🧪 테스트 데이터 정의

### Mock 데이터

```typescript
// 반복 일정 Mock 데이터
const mockRepeatEvent: Event = {
  id: '1',
  title: '팀 회의',
  date: '2025-11-03',
  startTime: '10:00',
  endTime: '11:00',
  description: '주간 팀 회의',
  location: '회의실 A',
  category: '업무',
  repeat: {
    type: 'daily',
    interval: 1,
    endDate: '2025-12-31',
  },
  notificationTime: 10,
};

// 단일 일정 Mock 데이터
const mockSingleEvent: Event = {
  id: '2',
  title: '개인 회의',
  date: '2025-11-05',
  startTime: '14:00',
  endTime: '15:00',
  description: '1:1 미팅',
  location: '회의실 B',
  category: '개인',
  repeat: {
    type: 'none',
    interval: 1,
  },
  notificationTime: 10,
};

// 수정된 반복 일정 (단일 변환)
const mockUpdatedSingleEvent: Event = {
  ...mockRepeatEvent,
  title: '수정된 팀 회의',
  repeat: {
    type: 'none',
    interval: 1,
    endDate: undefined,
  },
};

// 수정된 반복 일정 (반복 유지)
const mockUpdatedRepeatEvent: Event = {
  ...mockRepeatEvent,
  title: '수정된 팀 회의',
  repeat: {
    type: 'daily',
    interval: 1,
    endDate: '2025-12-31',
  },
};
```

### Fixture 데이터

```typescript
// 초기 이벤트 목록
const mockEvents: Event[] = [mockRepeatEvent, mockSingleEvent];

// API 응답 데이터
const mockApiResponse = {
  events: mockEvents,
};

// 에러 응답
const mockErrorResponse = {
  error: 'Failed to save event',
  message: '일정 저장에 실패했습니다.',
};
```

---

## 🎭 Mock/Stub 전략

### API Mocking (MSW)

```typescript
// 일정 조회 핸들러 (기본)
http.get('/api/events', () => {
  return HttpResponse.json({ events: mockEvents });
});

// 일정 수정 핸들러 (성공)
http.put('/api/events/:id', async ({ request, params }) => {
  const { id } = params;
  const updatedEvent = (await request.json()) as Event;

  // repeat.type 검증
  if (updatedEvent.repeat.type === 'none') {
    // 단일 수정 케이스
    return HttpResponse.json({
      ...updatedEvent,
      id,
      repeat: {
        type: 'none',
        interval: 1,
        endDate: undefined,
      },
    });
  } else {
    // 전체 수정 케이스
    return HttpResponse.json({
      ...updatedEvent,
      id,
    });
  }
});

// 일정 수정 핸들러 (실패)
http.put('/api/events/:id', () => {
  return new HttpResponse(JSON.stringify(mockErrorResponse), {
    status: 500,
    headers: {
      'Content-Type': 'application/json',
    },
  });
});
```

### setupMockHandlerUpdating 헬퍼 사용

```typescript
// 기존 handlersUtils.ts의 setupMockHandlerUpdating 활용
setupMockHandlerUpdating((eventData: Event) => {
  // 반복 일정 수정 케이스에 따른 응답 분기
  if (eventData.repeat.type === 'none') {
    return {
      ...eventData,
      repeat: {
        type: 'none',
        interval: 1,
        endDate: undefined,
      },
    };
  }
  return eventData;
});
```

---

## 📁 테스트 파일 구조

```
src/__tests__/
  └── medium.integration.spec.tsx  # 반복 일정 수정 통합 테스트 추가
```

### 예상 테스트 파일 목록

1. `src/__tests__/medium.integration.spec.tsx` - 반복 일정 수정 통합 테스트 (11개 테스트 케이스 추가)

### 테스트 그룹 구조

```typescript
describe('반복 일정 수정', () => {
  describe('다이얼로그 표시', () => {
    it('반복 일정 수정 시 다이얼로그가 표시된다', async () => {
      // 테스트 케이스 1
    });

    it('단일 일정 수정 시 다이얼로그가 표시되지 않는다', async () => {
      // 테스트 케이스 5
    });
  });

  describe('단일 수정 ("예" 버튼)', () => {
    it('"예" 버튼 클릭 시 단일 일정으로 변경된다', async () => {
      // 테스트 케이스 2
    });

    it('단일 수정 시 반복일정 아이콘이 사라진다', async () => {
      // 테스트 케이스 8
    });
  });

  describe('전체 수정 ("아니오" 버튼)', () => {
    it('"아니오" 버튼 클릭 시 반복 정보가 유지된다', async () => {
      // 테스트 케이스 3
    });
  });

  describe('수정 취소', () => {
    it('"취소" 버튼 클릭 시 수정이 취소된다', async () => {
      // 테스트 케이스 4
    });

    it('취소 후 다시 저장 버튼 클릭 시 다이얼로그가 다시 표시된다', async () => {
      // 테스트 케이스 10
    });
  });

  describe('에러 처리', () => {
    it('API 요청 실패 시 에러 메시지가 표시된다', async () => {
      // 테스트 케이스 6
    });
  });

  describe('UI 검증', () => {
    it('다이얼로그 UI 요소가 올바르게 표시된다', async () => {
      // 테스트 케이스 7
    });

    it('성공 메시지가 표시된다', async () => {
      // 테스트 케이스 9
    });
  });

  describe('엣지 케이스', () => {
    it('겹침 경고와 함께 동작한다', async () => {
      // 테스트 케이스 11
    });
  });
});
```

---

## 🎯 React Testing Library 쿼리 전략

### 사용할 쿼리 (우선순위 순)

1. **getByRole** ⭐ 최우선

```typescript
// 다이얼로그
screen.getByRole('dialog');

// 버튼
screen.getByRole('button', { name: '예' });
screen.getByRole('button', { name: '아니오' });
screen.getByRole('button', { name: '취소' });

// 제목
screen.getByRole('heading', { name: '반복 일정 수정' });

// 편집 버튼
screen.getByLabelText('Edit event');
```

2. **getByLabelText** - 폼 요소

```typescript
screen.getByLabelText('제목');
screen.getByLabelText('날짜');
```

3. **getByText** - 텍스트 콘텐츠

```typescript
screen.getByText('해당 일정만 수정하시겠어요?');
screen.getByText('일정이 수정되었습니다.');
```

4. **getByTestId** - 최후의 수단

```typescript
screen.getByTestId('event-submit-button');
screen.getByTestId('event-list');
```

### 비동기 처리

```typescript
// findBy: 비동기로 나타날 요소
const successMessage = await screen.findByText('일정이 수정되었습니다.');

// waitFor: 복잡한 조건 대기
await waitFor(() => {
  expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
});

// waitForElementToBeRemoved: 요소 사라짐 대기
await waitForElementToBeRemoved(() => screen.queryByRole('dialog'));
```

---

## ⚠️ 엣지 케이스 테스트

### 1. 반복 일정 수정 + 겹침 경고

**시나리오**: 반복 일정을 단일 수정하는데 수정 시간대에 다른 일정이 겹침

**검증 항목**:

- 반복 일정 다이얼로그가 먼저 표시되는가?
- "예" 선택 후 겹침 경고 다이얼로그가 표시되는가?
- 두 다이얼로그가 순차적으로 표시되는가?
- 최종적으로 저장이 완료되는가?

### 2. 사용자가 반복 체크박스 해제

**시나리오**: 반복 일정을 편집하면서 반복 체크박스를 해제

**검증 항목**:

- 다이얼로그가 표시되는가? (명세서에 따라 두 가지 해석 가능)
- 바로 저장되는가?
- 단일 일정으로 변경되는가?

**참고**: 명세서의 엣지 케이스 #2에서 두 가지 조건이 제시됨. 최종 구현에서 선택된 조건에 따라 테스트

### 3. 취소 후 재시도

**시나리오**: 다이얼로그에서 "취소" 후 다시 저장 버튼 클릭

**검증 항목**:

- 다이얼로그가 다시 표시되는가?
- 폼 데이터는 유지되는가?
- 사용자가 다시 선택할 수 있는가?

### 4. 네트워크 오류 발생

**시나리오**: API 요청 중 네트워크 오류 발생

**검증 항목**:

- 에러 메시지가 표시되는가?
- 다이얼로그가 닫히는가?
- 폼이 유지되는가?
- 사용자가 다시 시도할 수 있는가?

### 5. ESC 키 또는 배경 클릭

**시나리오**: 다이얼로그에서 ESC 키 또는 배경 클릭

**검증 항목**:

- 취소 동작이 실행되는가?
- API 요청이 발생하지 않는가?
- 폼이 유지되는가?

---

## 🚨 에러 처리 테스트

### 1. API 요청 실패 (500 에러)

**발생 조건**: 서버에서 500 Internal Server Error 반환

**예상 동작**:

- "일정 저장 실패" 에러 메시지 표시
- 다이얼로그 닫힘
- 폼 유지 (사용자가 다시 시도 가능)

**검증 방법**:

```typescript
server.use(
  http.put('/api/events/:id', () => {
    return new HttpResponse(null, { status: 500 });
  })
);

// "예" 버튼 클릭
await user.click(yesButton);

// 에러 메시지 확인
expect(await screen.findByText('일정 저장 실패')).toBeInTheDocument();
```

### 2. 네트워크 오류

**발생 조건**: 네트워크 연결 오류

**예상 동작**:

- "일정 저장 실패" 에러 메시지 표시
- 다이얼로그 닫힘
- 폼 유지

**검증 방법**:

```typescript
server.use(
  http.put('/api/events/:id', () => {
    return HttpResponse.error();
  })
);
```

---

## 📋 테스트 체크리스트

### 테스트 작성 전

- [x] 기능 명세서 검토 완료
- [x] 테스트 케이스가 인수 조건을 모두 커버하는가? (22개 인수 조건 → 11개 테스트 케이스)
- [x] Mock 전략이 명확한가? (MSW 핸들러 정의)
- [x] 테스트 데이터가 준비되었는가? (Mock 데이터 정의)

### 테스트 작성 중

- [ ] AAA 패턴을 따르는가?
- [ ] 접근성 쿼리를 우선 사용하는가? (getByRole 우선)
- [ ] userEvent.setup()을 사용하는가?
- [ ] 비동기 처리가 적절한가? (findBy, waitFor)

### 테스트 작성 후

- [ ] 모든 테스트가 실패하는가? (RED 단계)
- [ ] 테스트 이름이 명확한가?
- [ ] 중복 코드가 없는가? (beforeEach 활용)
- [ ] 테스트가 독립적으로 실행 가능한가?

---

## 📊 테스트 커버리지 목표

### 인수 조건 커버리지

- **총 인수 조건**: 22개
- **커버된 인수 조건**: 22개 (100%)
  - 다이얼로그 표시: 5개 ✓
  - "예" 선택 시: 7개 ✓
  - "아니오" 선택 시: 5개 ✓
  - "취소" 선택 시: 3개 ✓
  - 에러 처리: 2개 ✓

### 엣지 케이스 커버리지

- **총 엣지 케이스**: 5개
- **커버된 엣지 케이스**: 4개 (80%)
  - 반복 일정 + 겹침 경고: ✓ (테스트 케이스 11)
  - 반복 체크박스 해제: ⚠️ (명세서 명확화 필요)
  - 취소 후 재시도: ✓ (테스트 케이스 10)
  - 네트워크 오류: ✓ (테스트 케이스 6)
  - 서버 버그 상황: ✓ (단일 일정 수정 테스트로 커버)

---

## 📚 참고 문서

- **TDD 워크플로우 가이드**: `docs/tdd-workflow-guide.md`
- **프로젝트 구조**: `bmad-tdd/core/index.mdc`
- **React 베스트 프랙티스**: `bmad-tdd/core/rules/react.mdc`
- **기존 통합 테스트**: `src/__tests__/medium.integration.spec.tsx`
- **MSW 핸들러**: `src/__mocks__/handlers.ts`

---

## 🎯 다음 단계

테스트 설계가 완료되었습니다. @test-developer를 호출하여 실제 테스트 코드를 작성하세요.

**예상 작업**:

- `src/__tests__/medium.integration.spec.tsx`에 11개 테스트 케이스 추가
- MSW 핸들러 업데이트 (필요 시)
- 모든 테스트가 실패하는지 확인 (RED 단계)

---

**작성 완료**: 2025-10-31  
**다음 단계**: 테스트 코드 작성 (@test-developer)
